/**
 * @Description:decorator包主要学习装饰器模式
 * @author: 彭立
 * @date: 2018年9月4日 上午10:10:24
 * 
 */
package com.pl.decorator;

/**
 *
 * 为什么要用装饰器模式？装饰器模式适用的场景有哪些？
 * 
 * java是单继承的，如果只是对父类进行少量的功能扩展，而且不用考虑未来的需求变更或增加，继承是完全够用的
 * 但是如果要扩展大量的功能，而且功能与功能之前还可以排列组合为新功能，那么如果用继承的方式来做，势必造成“类的爆炸”或“方法的爆炸”
 * 举个栗子：
 * 假如有个烹饪父类，我们需要扩展这个烹饪父类
 * 如果我们用继承来做的话，我们会有加盐子类、加醋子类、加油子类、先加盐再加醋子类、先加醋再加盐子类、先加油再加盐再加醋子类、先加油再加盐子类。。。
 * 我们会看到用继承的方法来做的话要写特别多的子类，这就是“类爆炸”
 * 而且还有特别不好的一点就是加醋的方式变化了，如原来是加普通白醋的，现在变更为加山西老陈醋
 * 这时我们有两种办法：
 * 第一种保留原来的类不变，继续加更多的子类
 * 第二种修改原来的子类，如加醋子类、先加盐再加醋子类、先加醋再加盐子类、先加油再加盐再加醋子类，这些子类都修改一遍，想想都头大了。。
 * 
 * 
 * 这时候我们就需要一种设计模式有以下的特性：
 * 一、能够在运行时动态加上现在或者未来的一些方法的增强，需要的时候加上，不需要的时候就不加，不用“硬编码”到子类里面
 * 二、增强方法变更的时候，修改增强方法不会影响到现有已经写好的类
 *
 *
 *
 *
 */