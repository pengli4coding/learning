/**
 * @Description:demo2主要学习线程类java.lang.Thread的一些基本api的使用
 * @author: 彭立
 * @date:   2018年9月23日 下午6:00:19
 *   
 */
package com.pl.demo2;

/**
 * 
 * 1、获取调用当前代码的线程：currentThread()
 * 		请注意：currentThread()方法是用来获取调用当前代码的线程
 * 
 * 2、判断判断当前线程是否处于活动状态：isAlive()
 * 		用于判断当前线程是否处于活动状态，个人感觉这个方法还是比较少用的
 * 
 * 3、如何打断线程（即停止线程）
 * 		个人总结出来停止线程有如下两个方法：
 * 			异常法（推荐使用，见demo3）：
 * 				异常法主要通过打上打断标记（通过interrupt()方法）配合线程内部判断是否有打断标记（通过interrupted()方法或者isInterrupted()方法）来使用的
 * 				interrupted()方法和isInterrupted()方法的区别：
 * 					interrupted()方法：测试当前线程是否已经被打上打断退出标记，执行后打断退出标记会被清除，即由true变成false
 * 					isInterrupted()方法：测试当前线程是否已经被打上打断退出标记，执行后打断退出标记不会被清除，即一直都是true
 * 			return法（推荐使用，见demo4）：
 * 				return法主要通过打上打断标记（通过interrupt()方法）配合线程内部的return来使用的
 * 			stop()方法（已过期，不推荐使用）：
 * 				既然都过期了，还介绍来干嘛
 * 
 * 4、让当前线程让出时间片yield（说白了就是暂停当前线程，让别的线程去执行）：
 * 		yield()方法的作用是放弃当前的CPU资源，将它让给其它的任务去占用CPU执行时间，但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片
 * 
 * 5、线程的优先级：
 * 		线程的优先级通过setPriority()方法来指定，优先级从1~10的范围内
 * 		Thread类提供了三种优先级常量：
 * 			MIN_PRIORITY = 1
 * 			NORM_PRIORITY = 5
 * 			MAX_PRIORITY = 10
 * 
 * 6、守护线程：
 * 		守护线程是为非守护线程服务的，当虚拟机中所有的非守护线程都运行完毕之后，哪怕还有守护线程在运行，虚拟机都会直接退出
 * 		可以理解为守护线程的生命周期是在非守护线程的生命周期之内的
 * 		设置线程为守护线程可以通过setDaemon()方法来设置，而且必须要在start()方法之前设置，不然会无效
 * 
 */